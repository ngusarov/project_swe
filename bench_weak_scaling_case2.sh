#!/bin/bash
#SBATCH --qos=math-454
#SBATCH --account=math-454
#SBATCH --output=bench_output_weak_scaling_%j.txt
#SBATCH --cpus-per-task=1
#SBATCH --time=03:00:00 # Increased time limit for larger runs
#SBATCH -n 72

# This script performs weak scaling benchmarks for test_case_id 2.
# It keeps the problem size per process constant and scales the total problem size
# with the number of processes. Multiple curves are generated by varying the
# "base" local problem size for a single process.

# Ensure your executable is compiled and named 'swe'
# Example: make swe

module purge && module load gcc openmpi hdf5/1.12.2-mpi

TEST_CASE=2 # Using test case 2 for all weak scaling runs
TEND=0.005    # Simulation time in hours (fixed for all runs)
OUTPUT_N=0  # No output files for performance benchmarking

# Define different "base" local grid sizes for a single process.
# These will determine the constant problem size per core.
LOCAL_BASE_SIZES=(300) # 300 # Example: 100x100, 200x200, 300x300 cells per process

# Number of processes to test.
# Vary densely from 1 to 32, then more sparsely up to 72.
PROCS=(1 2 4 8 12 16 20 24 28 32 40 48 56 64 72) 

REPEAT=2 # Number of repetitions for each configuration

# Create a directory for benchmark results if it doesn't exist
mkdir -p bench_results_weak_scaling

# Define the header for the CSV output file

# echo "test_case,local_base_size,global_nx,global_ny,procs,run,total_time_seconds,num_iterations,time_per_iteration" > bench_results_weak_scaling/timings_weak_scaling_case2.csv

# Helper function to simulate MPI_Dims_create behavior for 2D decomposition
# This provides the (dim_x, dim_y) for a given number of processes.
# This function is a heuristic; for exact values, one would run a small MPI program.
get_dims() {
  local num_procs=$1
  local dim_x=0
  local dim_y=0

  # Pre-calculated common decompositions for better accuracy
  if (( num_procs == 1 )); then dim_x=1; dim_y=1;
  elif (( num_procs == 2 )); then dim_x=2; dim_y=1;
  elif (( num_procs == 4 )); then dim_x=2; dim_y=2;
  elif (( num_procs == 8 )); then dim_x=4; dim_y=2;
  elif (( num_procs == 12 )); then dim_x=4; dim_y=3;
  elif (( num_procs == 16 )); then dim_x=4; dim_y=4;
  elif (( num_procs == 20 )); then dim_x=5; dim_y=4;
  elif (( num_procs == 24 )); then dim_x=6; dim_y=4;
  elif (( num_procs == 28 )); then dim_x=7; dim_y=4;
  elif (( num_procs == 32 )); then dim_x=8; dim_y=4;
  elif (( num_procs == 40 )); then dim_x=8; dim_y=5;
  elif (( num_procs == 48 )); then dim_x=8; dim_y=6;
  elif (( num_procs == 56 )); then dim_x=8; dim_y=7;
  elif (( num_procs == 64 )); then dim_x=8; dim_y=8;
  elif (( num_procs == 72 )); then dim_x=9; dim_y=8;
  else
    # Fallback for other numbers of processes: find factors
    dim_x=$(python -c "import math; p=$num_procs; x=int(math.sqrt(p)); while p%x != 0: x-=1; print(x)")
    dim_y=$(( num_procs / dim_x ))
  fi
  echo "$dim_x $dim_y"
}

# Loop through each defined base local size
for LOCAL_BASE_SIZE in "${LOCAL_BASE_SIZES[@]}"; do
  echo "--- Starting weak scaling for local base size: ${LOCAL_BASE_SIZE}x${LOCAL_BASE_SIZE} ---"
  
  # Loop through each number of processes
  for NPROCS in "${PROCS[@]}"; do
    # Get the 2D decomposition dimensions for the current number of processes
    read -r DIMS_X DIMS_Y <<< $(get_dims $NPROCS)

    # Calculate the total global grid dimensions for weak scaling
    # This ensures that each process ideally handles a LOCAL_BASE_SIZE x LOCAL_BASE_SIZE block.
    GLOBAL_NX=$(( LOCAL_BASE_SIZE * DIMS_X ))
    GLOBAL_NY=$(( LOCAL_BASE_SIZE * DIMS_Y ))

    # Skip if the calculated global dimensions become excessively large,
    # which might lead to out-of-memory errors or extremely long runtimes.
    # Adjust the maximum size (e.g., 4000) based on your system's capabilities.
    if (( GLOBAL_NX > 4000 || GLOBAL_NY > 4000 )); then
        echo "Skipping NPROCS=$NPROCS (Global grid ${GLOBAL_NX}x${GLOBAL_NY}) - too large for weak scaling with base size ${LOCAL_BASE_SIZE}."
        continue
    fi

    # Loop for repetitions
    for ((i = 1; i <= REPEAT; i++)); do
      # Generate a unique temporary output file name for each run
      TEMP_OUTPUT_FILE="tmp_output_weak_case2_${LOCAL_BASE_SIZE}_${NPROCS}_${i}_$$_${SLURM_JOB_ID}.txt"
      
      echo "[RUNNING] Weak Scaling: Base ${LOCAL_BASE_SIZE}x${LOCAL_BASE_SIZE}, NPROCS=$NPROCS, Global ${GLOBAL_NX}x${GLOBAL_NY} (run $i)"
      
      # Ensure OMP_NUM_THREADS is set to 1 for pure MPI benchmarks
      export OMP_NUM_THREADS=1

      # Execute the SWE solver with the calculated global dimensions
      # --full-log is enabled to ensure "Simulation finished after X steps" is printed,
      # which is needed to extract the number of iterations.
      srun -n $NPROCS ./swe \
        --test-case $TEST_CASE \
        --Tend $TEND \
        --global-nx $GLOBAL_NX \
        --global-ny $GLOBAL_NY \
        --output-n $OUTPUT_N \
        --output-prefix "weak_scaling_case${TEST_CASE}_Base${LOCAL_BASE_SIZE}_P${NPROCS}" \
        --full-log \
        2>&1 | tee "$TEMP_OUTPUT_FILE"

      # Extract the total simulation time, number of iterations, and time per iteration
      TOTAL_TIME=$(grep "\[TIMING\]" "$TEMP_OUTPUT_FILE" | awk '{print $(NF-1)}')
      NUM_ITERATIONS=$(grep "\[ITERATIONS\]" "$TEMP_OUTPUT_FILE" | awk '{print $(NF)}')
      TIME_PER_ITERATION=$(grep "\[TIME_PER_ITER\]" "$TEMP_OUTPUT_FILE" | awk '{print $(NF-1)}')

      # Check if all metrics were successfully extracted
      if [ -z "$TOTAL_TIME" ] || [ -z "$NUM_ITERATIONS" ] || [ -z "$TIME_PER_ITERATION" ]; then
          echo "WARNING: Could not extract all metrics for weak scaling: Base ${LOCAL_BASE_SIZE}x${LOCAL_BASE_SIZE}, NPROCS=$NPROCS (run $i). Output below:"
          cat "$TEMP_OUTPUT_FILE" # Print the content of the temp file for debugging
          TOTAL_TIME="ERROR"       # Mark as ERROR in CSV if extraction failed
          NUM_ITERATIONS="ERROR"
          TIME_PER_ITERATION="ERROR"
      fi

      # Append the results to the CSV file
      echo "$TEST_CASE,$LOCAL_BASE_SIZE,$GLOBAL_NX,$GLOBAL_NY,$NPROCS,$i,$TOTAL_TIME,$NUM_ITERATIONS,$TIME_PER_ITERATION" >> bench_results_weak_scaling/timings_weak_scaling_case2.csv
      
      # Clean up the temporary output file
      rm "$TEMP_OUTPUT_FILE"
    done
  done
done

echo "Weak scaling for Test Case $TEST_CASE completed. Results in bench_results_weak_scaling/timings_weak_scaling_case2.csv"
